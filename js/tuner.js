let audioContext;
let analyser;
let microphone;
let dataArray;
let bufferLength;
let animationId;
let frequencyBuffer = [];
const bufferSize = 5;
let lastDisplayedFrequency = null;
const frequencyThreshold = 1; // Hz threshold for updating display

let customTuningConfig = null;

const tuningSystemDescriptions = {
    equal: "Standard 12-tone equal temperament with A=440Hz, generated by splitting an octave into 12 equal steps",
    equal432: "12-tone equal temperament tuned to A=432Hz",
    just: "Just intonation based on pure integer ratios",
    meantone: "Quarter-comma meantone temperament. Made by stacking just fifths, each flattened by a quarter of a syntonic comma",
    "31edo": "31 equal divisions of the octave",
    custom: "User-defined custom tuning system"
};

const names31 = [
    'A',
    'At/Bbb',
    'A#/Bdb',
    'A#t/Bb',
    'A##/Bd',
    'B',
    'Bt/Cb',
    'B#/Cd',
    'C',
    'Ct/Dbb',
    'C#/Ddb',
    'C#t/Db',
    'C##/Dd',
    'D',
    'Dt/Ebb',
    'D#/Edb',
    'D#t/Eb',
    'D##/Ed',
    'E',
    'Et/Fb',
    'E#/Fd',
    'F',
    'Ft/Gbb',
    'F#/Gdb',
    'F#t/Gb',
    'F##/Gd',
    'G',
    'Gt/Abb',
    'G#/Adb',
    'G#t/Ab',
    'G##/Ad'
];

const presetTuningSystems = {
    equal: {
        baseFreq: 440,
        repeatRatio: 2,
        steps: [
            { name: 'A',  cents: 0,    ratio: 1 },
            { name: 'A#/Bb', cents: 100,  ratio: Math.pow(2, 100/1200) },
            { name: 'B',  cents: 200,  ratio: Math.pow(2, 200/1200) },
            { name: 'C',  cents: 300,  ratio: Math.pow(2, 300/1200) },
            { name: 'C#/Db', cents: 400,  ratio: Math.pow(2, 400/1200) },
            { name: 'D',  cents: 500,  ratio: Math.pow(2, 500/1200) },
            { name: 'D#/Eb', cents: 600,  ratio: Math.pow(2, 600/1200) },
            { name: 'E',  cents: 700,  ratio: Math.pow(2, 700/1200) },
            { name: 'F',  cents: 800,  ratio: Math.pow(2, 800/1200) },
            { name: 'F#/Gb', cents: 900,  ratio: Math.pow(2, 900/1200) },
            { name: 'G',  cents: 1000, ratio: Math.pow(2, 1000/1200) },
            { name: 'G#/Ab', cents: 1100, ratio: Math.pow(2, 1100/1200) }
        ]
    },
    equal432: {
        baseFreq: 432,
        repeatRatio: 2,
        steps: [
            { name: 'A',  cents: 0,    ratio: 1 },
            { name: 'A#/Bb', cents: 100,  ratio: Math.pow(2, 100/1200) },
            { name: 'B',  cents: 200,  ratio: Math.pow(2, 200/1200) },
            { name: 'C',  cents: 300,  ratio: Math.pow(2, 300/1200) },
            { name: 'C#/Db', cents: 400,  ratio: Math.pow(2, 400/1200) },
            { name: 'D',  cents: 500,  ratio: Math.pow(2, 500/1200) },
            { name: 'D#/Eb', cents: 600,  ratio: Math.pow(2, 600/1200) },
            { name: 'E',  cents: 700,  ratio: Math.pow(2, 700/1200) },
            { name: 'F',  cents: 800,  ratio: Math.pow(2, 800/1200) },
            { name: 'F#/Gb', cents: 900,  ratio: Math.pow(2, 900/1200) },
            { name: 'G',  cents: 1000, ratio: Math.pow(2, 1000/1200) },
            { name: 'G#/Ab', cents: 1100, ratio: Math.pow(2, 1100/1200) }
        ]
    },
    just: {
        baseFreq: 440,
        repeatRatio: 2,
        steps: [
            { name: 'A',  cents: 0,                               ratio: 1 },
            { name: 'A#/Bb', cents: 1200 * Math.log2(16/15),         ratio: 16/15 },
            { name: 'B',  cents: 1200 * Math.log2(9/8),           ratio: 9/8 },
            { name: 'C',  cents: 1200 * Math.log2(6/5),           ratio: 6/5 },
            { name: 'C#/Db', cents: 1200 * Math.log2(5/4),           ratio: 5/4 },
            { name: 'D',  cents: 1200 * Math.log2(4/3),           ratio: 4/3 },
            { name: 'D#/Eb', cents: 1200 * Math.log2(45/32),         ratio: 45/32 },
            { name: 'E',  cents: 1200 * Math.log2(3/2),           ratio: 3/2 },
            { name: 'F',  cents: 1200 * Math.log2(8/5),           ratio: 8/5 },
            { name: 'F#/Gb', cents: 1200 * Math.log2(5/3),           ratio: 5/3 },
            { name: 'G',  cents: 1200 * Math.log2(9/5),           ratio: 9/5 },
            { name: 'G#/Ab', cents: 1200 * Math.log2(15/8),          ratio: 15/8 }
        ]
    },
    meantone: {
        baseFreq: 440,
        repeatRatio: 2,
        steps: [
            { name: 'A',  cents: 0,    ratio: Math.pow(2, 0/1200) },
            { name: 'A#/Bb', cents: 76,   ratio: Math.pow(2, 76/1200) },
            { name: 'B',  cents: 193,  ratio: Math.pow(2, 193/1200) },
            { name: 'C',  cents: 310,  ratio: Math.pow(2, 310/1200) },
            { name: 'C#/Db', cents: 386,  ratio: Math.pow(2, 386/1200) },
            { name: 'D',  cents: 503,  ratio: Math.pow(2, 503/1200) },
            { name: 'D#/Eb', cents: 579,  ratio: Math.pow(2, 579/1200) },
            { name: 'E',  cents: 697,  ratio: Math.pow(2, 697/1200) },
            { name: 'F',  cents: 773,  ratio: Math.pow(2, 773/1200) },
            { name: 'F#/Gb', cents: 890,  ratio: Math.pow(2, 890/1200) },
            { name: 'G',  cents: 1007, ratio: Math.pow(2, 1007/1200) },
            { name: 'G#/Ab', cents: 1083, ratio: Math.pow(2, 1083/1200) }
        ]
    },
    "31edo": {
        baseFreq: 440,
        repeatRatio: 2,
        steps: Array.from({length: 31}, (_, i) => ({
            name: names31[i],
            cents: i * (1200/31),
            ratio: Math.pow(2, (i * 1200/31) / 1200)
        }))
    }
};

function updateSystemInfo() {
    const system = document.getElementById('tuningSystem').value;
    if (system === 'custom' && customTuningConfig) {
        const steps = customTuningConfig.steps.map(s => `${s.name}: ${s.originalValue}`).join(', ');
        document.getElementById('systemInfo').textContent = 
            `Custom tuning with ${customTuningConfig.steps.length} steps. ` +
            `Reference: ${customTuningConfig.baseFreq}Hz. ` +
            `Repeat: ${customTuningConfig.repeatRatio.toFixed(3)}. ` +
            `Steps: ${steps}`;
    } else if (system !== 'custom') {
        const config = presetTuningSystems[system];
        document.getElementById('systemInfo').textContent = 
            tuningSystemDescriptions[system] + 
            ` (${config.steps.length} steps, reference: ${config.baseFreq}Hz)`;
    } else {
        document.getElementById('systemInfo').textContent = tuningSystemDescriptions[system];
    }
}

function parseInterval(intervalStr) {
    intervalStr = intervalStr.trim();
    
    // Check if it's a ratio (contains /)
    if (intervalStr.includes('/')) {
        const parts = intervalStr.split('/');
        if (parts.length !== 2) return null;
        const num = parseFloat(parts[0]);
        const den = parseFloat(parts[1]);
        if (isNaN(num) || isNaN(den) || den === 0) return null;
        return { type: 'ratio', value: num / den };
    }
    
    // Otherwise treat as cents
    const cents = parseFloat(intervalStr);
    if (isNaN(cents)) return null;
    return { type: 'cents', value: cents };
}

function intervalToCents(interval) {
    if (interval.type === 'cents') {
        return interval.value;
    } else {
        return 1200 * Math.log2(interval.value);
    }
}

function applyCustomTuning() {
    const errorDiv = document.getElementById('customError');
    errorDiv.textContent = '';
    
    try {
        const baseFreq = parseFloat(document.getElementById('customBaseFreq').value);
        if (isNaN(baseFreq) || baseFreq <= 0) {
            throw new Error('Invalid reference frequency');
        }
        
        const repeatStr = document.getElementById('customRepeat').value.trim();
        const repeatInterval = parseInterval(repeatStr);
        if (!repeatInterval) {
            throw new Error('Invalid repeat interval format');
        }
        const repeatRatio = repeatInterval.type === 'ratio' ? 
            repeatInterval.value : 
            Math.pow(2, repeatInterval.value / 1200);
        
        const stepsText = document.getElementById('customSteps').value;
        const lines = stepsText.split('\n').filter(line => line.trim());
        
        if (lines.length === 0) {
            throw new Error('Please define at least one step');
        }
        
        const steps = [];
        for (let line of lines) {
            const parts = line.split(',').map(p => p.trim());
            if (parts.length !== 2) {
                throw new Error(`Invalid format in line: "${line}". Use format: name, interval`);
            }
            
            const name = parts[0];
            const intervalStr = parts[1];
            const interval = parseInterval(intervalStr);
            
            if (!interval) {
                throw new Error(`Invalid interval in line: "${line}"`);
            }
            
            const cents = intervalToCents(interval);
            const ratio = interval.type === 'ratio' ? interval.value : Math.pow(2, interval.value / 1200);
            
            steps.push({
                name: name,
                cents: cents,
                ratio: ratio,
                originalValue: intervalStr
            });
        }
        
        customTuningConfig = {
            baseFreq: baseFreq,
            repeatRatio: repeatRatio,
            steps: steps
        };
        
        updateSystemInfo();
        errorDiv.style.color = '#000';
        errorDiv.textContent = '✓ Custom tuning applied successfully!';
        
        setTimeout(() => {
            errorDiv.textContent = '';
        }, 3000);
        
    } catch (error) {
        errorDiv.style.color = '#000';
        errorDiv.textContent = '✗ ' + error.message;
    }
}

async function startTuner() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: {
                echoCancellation: false,
                autoGainControl: false,
                noiseSuppression: false,
                latency: 0
            } 
        });
        
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        
        analyser.fftSize = 16384;
        analyser.smoothingTimeConstant = 0;
        bufferLength = analyser.fftSize;
        dataArray = new Float32Array(bufferLength);
        
        microphone.connect(analyser);
        
        frequencyBuffer = [];
        lastDisplayedFrequency = null;
        
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('stopBtn').style.display = 'inline-block';
        
        updatePitch();
    } catch (err) {
        alert('Microphone access denied. Please allow microphone access to use the tuner.');
    }
}

function stopTuner() {
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
    if (microphone) {
        microphone.disconnect();
    }
    if (audioContext) {
        audioContext.close();
    }
    
    frequencyBuffer = [];
    lastDisplayedFrequency = null;
    
    document.getElementById('startBtn').style.display = 'inline-block';
    document.getElementById('stopBtn').style.display = 'none';
    document.getElementById('noteDisplay').textContent = '--';
    document.getElementById('frequencyDisplay').textContent = '-- Hz';
    document.getElementById('centsDisplay').textContent = '-- cents';
    document.getElementById('tuningIndicator').style.left = '50%';
}

function autoCorrelate(buffer, sampleRate) {
    let size = buffer.length;
    let rms = 0;

    // detect when there is no mic input
    for (let i = 0; i < size; i++) {
        let val = buffer[i];
        rms += val * val;
    }
    rms = Math.sqrt(rms / size);
    
    if (rms < 0.005) return -1;

    let r1 = 0, r2 = size - 1, thres = 0.2;
    for (let i = 0; i < size / 2; i++) {
        if (Math.abs(buffer[i]) < thres) { 
            r1 = i; 
            break; 
        }
    }
    for (let i = 1; i < size / 2; i++) {
        if (Math.abs(buffer[size - i]) < thres) { 
            r2 = size - i; 
            break; 
        }
    }

    buffer = buffer.slice(r1, r2);
    size = buffer.length;

    let c = new Array(size).fill(0);
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size - i; j++) {
            c[i] = c[i] + buffer[j] * buffer[j + i];
        }
    }

    let d = 0;
    while (c[d] > c[d + 1]) d++;
    
    let maxval = -1, maxpos = -1;
    for (let i = d; i < size; i++) {
        if (c[i] > maxval) {
            maxval = c[i];
            maxpos = i;
        }
    }
    
    let T0 = maxpos;

    let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
    let a = (x1 + x3 - 2 * x2) / 2;
    let b = (x3 - x1) / 2;
    if (a) T0 = T0 - b / (2 * a);

    return sampleRate / T0;
}

function getFrequencyForNote(note, octave, system) {
    const config = system === 'custom' && customTuningConfig ? 
        customTuningConfig : 
        presetTuningSystems[system];
        
    if (!config) return null;
    
    const step = config.steps.find(s => s.name === note);
    if (!step) return null;
    
    const octaveMultiplier = Math.pow(config.repeatRatio, octave - 4);
    return config.baseFreq * step.ratio * octaveMultiplier;
}

function getNoteFromFrequency(frequency, system) {
    const config = system === 'custom' && customTuningConfig ? 
        customTuningConfig : 
        presetTuningSystems[system];
        
    if (!config) return null;
    
    let minDiff = Infinity;
    let closestNote = null;
    let closestOctave = null;
    let closestFreq = null;

    for (let octave = 0; octave < 10; octave++) {
        for (let step of config.steps) {
            const octaveMultiplier = Math.pow(config.repeatRatio, octave - 4);
            const targetFreq = config.baseFreq * step.ratio * octaveMultiplier;
            const diff = Math.abs(frequency - targetFreq);
            
            if (diff < minDiff) {
                minDiff = diff;
                closestNote = step.name;
                closestOctave = octave;
                closestFreq = targetFreq;
            }
        }
    }

    const cents = 1200 * Math.log2(frequency / closestFreq);
    
    const noteDisplay = system === '31edo' ? 
        `${closestNote}/${closestOctave}` : 
        `${closestNote}${closestOctave}`;
    
    return {
        note: noteDisplay,
        cents: cents.toFixed(1),
        frequency: closestFreq
    };
}

function updatePitch() {
    analyser.getFloatTimeDomainData(dataArray);
    const frequency = autoCorrelate(dataArray, audioContext.sampleRate);
    
    if (frequency > 0 && frequency < 2000) {
        frequencyBuffer.push(frequency);
        if (frequencyBuffer.length > bufferSize) {
            frequencyBuffer.shift();
        }

        const sortedFreqs = [...frequencyBuffer].sort((a, b) => a - b);
        const medianFreq = sortedFreqs[Math.floor(sortedFreqs.length / 2)];

        if (lastDisplayedFrequency === null || 
            Math.abs(medianFreq - lastDisplayedFrequency) > frequencyThreshold) {
            
            lastDisplayedFrequency = medianFreq;
            
            const system = document.getElementById('tuningSystem').value;
            const result = getNoteFromFrequency(medianFreq, system);
            
            document.getElementById('noteDisplay').textContent = result.note;
            document.getElementById('frequencyDisplay').textContent = medianFreq.toFixed(1) + ' Hz';
            document.getElementById('centsDisplay').textContent = (result.cents >= 0 ? '+' : '') + result.cents + ' cents';
            
            const centsValue = parseFloat(result.cents);
            const position = 50 + (centsValue / 50) * 50;
            const clampedPosition = Math.max(0, Math.min(100, position));
            document.getElementById('tuningIndicator').style.left = clampedPosition + '%';
            
            if (Math.abs(centsValue) < 5) {
                document.getElementById('noteDisplay').style.color = '#000';
                document.getElementById('noteDisplay').style.fontWeight = 'bold';
            } else if (Math.abs(centsValue) < 15) {
                document.getElementById('noteDisplay').style.color = '#666';
                document.getElementById('noteDisplay').style.fontWeight = 'bold';
            } else {
                document.getElementById('noteDisplay').style.color = '#000';
                document.getElementById('noteDisplay').style.fontWeight = 'normal';
            }
        }
    }
    
    animationId = requestAnimationFrame(updatePitch);
}

function initTuner() {
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const tuningSystem = document.getElementById('tuningSystem');
    const applyCustom = document.getElementById('applyCustom');
    
    if (!startBtn || !stopBtn || !tuningSystem || !applyCustom) {
        console.error('Tuner elements not found');
        return;
    }
    
    startBtn.addEventListener('click', startTuner);
    stopBtn.addEventListener('click', stopTuner);
    tuningSystem.addEventListener('change', (e) => {
        const isCustom = e.target.value === 'custom';
        document.getElementById('customTuningPanel').style.display = isCustom ? 'block' : 'none';
        updateSystemInfo();
    });
    applyCustom.addEventListener('click', applyCustomTuning);
    
    updateSystemInfo();
}

window.initTuner = initTuner;